<?xml version="1.0"?>
<!--Removing RST_TYPE_* parameters on page2 and page 3-->
<!--Removing init on page 4 -->
<!--chnages made to UI code on 11/10/2009 -->
<!--WREN_SENSE_B defailt value in UI on active low is chnaged from 2 to 0 (this doent casue any logic error but chnage to be in equivalence with spec) -->
<!--MAX alue of ADDR_WIDTH parametre is limited to 24 -->
<!-- -->
<dyndialog>

<dialog id="ipdesign_byteenableram" text="Byte Enable Ram Wizard" width="850" height="650">


   	 
    <graph_def id="graph_def1" fgcolor="white" bgcolor="#909090"> 
	    <text x="40" y="180">BYTE ENABLE RAM</text>

             <in name="ClkA"                        width="2" color="blue" />
	     <in name="AddrA"                       width="2" color="blue" />
	     <in name="WrDataA"                     width="2" color="blue" />
	     <in name="WenA"                        width="2" color="blue" enabled_if="WrEn_A"/>
	     <in name="ResetA"                      width="2" color="blue" enabled_if="RESET_A"/>


	     <in name="" width="0" color="#909090" />  <!-- Add a blank line between PortA & PortB -->

             <in name="ClkB"                        width="2" color="blue" enabled_if="X8_DPRAM" /> 
	     <in name="AddrB"                       width="2" color="blue" enabled_if="X8_DPRAM" />
	     <in name="WrDataB"                     width="2" color="blue" enabled_if="X8_DPRAM" />
	     <in name="ResetB"                      width="2" color="blue" enabled_if="X8_DPRAM and RESET_B" />
	     <in name="WenB"                        width="2" color="blue" enabled_if="X8_DPRAM and WrEn_B" />

	     <out name="RdDataA"                    width="2" color="blue" />

	     <in name="" width="0" color="#909090" />  <!-- Add a blank line between PortA & PortB -->
	     
	     <out name="RdDataB"                    width="2" color="blue" enabled_if="X8_DPRAM" />

   	 

   </graph_def>

   
      <!-- GUI Design -->
<tab id="parameters" text="BYTE ENABLE RAM Parameters">

      <hline> 

      <graph id="graph1" def="graph_def1" text="SynCore BYTE ENABLE RAM" width="300" height="550">
      </graph>     
      
  <!-- Start of Page 1 -->
      
      <page id="page1" text="Byte Enable Ram Compiler">
  
  <!-- Component feild -->
  
      <lineedit id="X1_COMPONENT" text="Component Name" required="true">
           <value></value>
      </lineedit>        
  
      <line /> <!-- This is to add an line separator -->
  
  <!-- Directory feild -->
 
      <lineedit id="X2_DIRECTORY" type="directory" text="Directory" required="true" tooltip="Spaces in Directory path not supported">   
           <value></value>
     </lineedit>	
     <line />   <!-- This is to add an line separator -->

 <!-- Filename feild -->
  
     <lineedit id="X3_FILENAME" type="save_file" text="File Name" required="true" tooltip="Filename should not be with .v extension"> 
          <value></value>
     </lineedit>	

 <!-- Memory Size Feild -->

	<group text="Memory Size">
 
               <lineedit id="X4_ADDRWIDTH" text="Address Width" type="int" posttext="Valid Range 2..20" required="true">
                  <value>2</value>
                  <min_value>2</min_value>
		  		  <max_value>20</max_value>
	       </lineedit>

               <lineedit id="X5_DATAWIDTH" text="Data Width" type="int" posttext="valid range 2..256" required="true">
                  <value>2</value>
                  <min_value>2</min_value>
                  <max_value>256</max_value>
               </lineedit>	  

               <lineedit id="X6_WENWIDTH" text="Write Enable Width" type="int" posttext="Valid Range 2..256" required="true">
                  <value>2</value>
                  <min_value>2</min_value>
                  <max_value>256</max_value>
               </lineedit>
              
          </group>
            
  <line /> <!-- This is to add an line separator -->
  
  
<group text="How will you be using the RAM?">      	
   <hline>
   
	 <radio id="X7_SPRAM" text="Single Port">	
	     <value>true</value>	     
 	     <on_value>CONFIG_PORT=0</on_value>
	 </radio> 

	<radio id="X8_DPRAM" text="Dual Port">	   	
	     <on_value>CONFIG_PORT=1</on_value> 
	     <value>false</value>	      	 
	</radio> 	          
        
   </hline>	 
 </group>
 
 
 <!-- line /> 
  
    <group text="Which clocking method do you want to use?">
       <hline>
	 <radio id="X9_NO_OF_CLOCKS" text="Single Clock" checked_if="X7_SPRAM">	     
	     <on_value>NO_OF_CLOCKS=1</on_value> 	     
	 </radio> 
	   
	 <radio id="X10_DUAL_CLOCKS" text="Separate Clocks For Each Port" enabled_if="!X7_SPRAM">	   	
	     <on_value>NO_OF_CLOCKS=2</on_value> 	     
	 </radio> 	   
       </hline>	
    </group>  -->
    
 </page> <!-- End of Page 1 -->
    
 <!-- Start of Page 2 -->
 <page id="page2">

	<line /> <!-- This is to add an line separator -->	
 	     <text> Configuring Port A </text>
 	<line /> <!-- This is to add an line separator -->


       <group text="How do you want to configure Port A ">
	  <hline>
	  	    
	 <radio id="Read_Write_A" text="Read And Write Access" checked_if="X7_SPRAM">	   
	      <value>true</value>
	      <on_value>READ_WRITE_A=1</on_value> 	      
	    </radio>	         

	    <radio id="Read_Only_A" text="Read Only Access" enabled_if="!Read_Only_B and X8_DPRAM" >
	    	 <value>false</value>
	         <on_value>READ_WRITE_A=2</on_value> 	         
	    </radio>	          
	    
	    <radio id="Write_Only_A" text="Write Only Access" enabled_if="!Write_Only_B and X8_DPRAM">
	        <value>false</value>
	        <on_value>READ_WRITE_A=3</on_value>	        
	    </radio>
	   </hline>
        </group>
	
	<line /> <!-- This is to add an line separator -->

       <group text="Pipelining Address Bus and Output Data ">
       
	       <check id="RADDR_LTNCY_A" text="Register address bus AddrA" level="1" >
         		<value>false</value>
         		<on_value>RADDR_LTNCY_A=1</on_value>
            	        <off_value>RADDR_LTNCY_A=0</off_value>
            	</check>
            	
            	<check id="RDATA_LTNCY_A" text="Register output data bus RdDataA" level="1" enabled_if="RADDR_LTNCY_A" checked_if="X7_SPRAM and !RADDR_LTNCY_A" >
         		<value>false</value>
         		<on_value>RDATA_LTNCY_A=1</on_value>
            	        <off_value>RDATA_LTNCY_A=0</off_value>
            	</check>
        </group>    


        <group text="Configure Reset Options" >
                 
                  <check id="RESET_A" text="Reset for RdDataA" level="1" enabled_if="RDATA_LTNCY_A" unchecked_if="RADDR_LTNCY_A and !RDATA_LTNCY_A" >
                  <value>true</value>
		  <on_value>ResetA=1</on_value>
            	  <off_value>ResetA=0</off_value>
            	  </check>
            	  <!--hline >
             	         <radio id="SRST_A" text="Synchronous Reset" level="2" enabled_if="RESET_A and RADDR_LTNCY_A or RESET_A and RDATA_LTNCY_A" >
            	              <on_value>RST_TYPE_A_UI=1</on_value>
              	         </radio>
                         <radio id="ARST_A" text="Asynchronous Reset" level="2" enabled_if="RESET_A and RADDR_LTNCY_A or RESET_A and RDATA_LTNCY_A" >
            	              <on_value>RST_TYPE_A_UI=2</on_value>
            	         </radio>
           	       </hline -->
       </group>

       <group text="Specify output data on reset" >
                   <hline>
                   <check id="RST_A_DFLT"  level="1" checked_if="RESET_A and !RST_A_NDFLT" unchecked_if="!RESET_A or RESET_A and RST_A_NDFLT" enabled_if="RESET_A" >
                         <value>true</value>
                         <on_value>RST_A_DFLT=1</on_value>
                         <off_value>RST_A_DFLT=0</off_value>
                   </check>  
		   <text>Default value of '1' for all bits</text>
		   </hline>
                 
                   <hline>                  
                   <check id="RST_A_NDFLT" level="1" checked_if="RESET_A and !RST_A_DFLT" unchecked_if="!RESET_A or RESET_A and RST_A_DFLT" enabled_if="RESET_A" >
                         <value>false</value> 
                         <on_value>RST_A_NDFLT=1</on_value>
                         <off_value>RST_A_NDFLT=0</off_value>
                   </check>
                                                        
                   <lineedit id="RST_RDDATA_A_UI" text="Specify Reset value for RdDataA" type="int" posttext="Valid Range 0...2^DATA_WIDTH" enabled_if="RST_A_NDFLT" required_if="RST_A_NDFLT" >
		   </lineedit>
                   </hline>
	   </group>        	 


        <group text="Configure Write Enable Options" >
                 
		<check id="WrEn_A" text="Write Enable for PORTA" level="1" enabled_if="X8_DPRAM" checked_if="X7_SPRAM" >
                  <value>true</value>
		  <on_value>WrEn_A=1</on_value>
            	  <off_value>WrEn_A=0</off_value>
            	  </check>
            	  <hline >
             	         <radio id="WrEn_A_AH" text="Active High" level="2" enabled_if="WrEn_A" >
            	              <on_value>WEN_SENSE_A=1</on_value>
              	         </radio>
                         <radio id="WeEn_A_AL" text="Active Low" level="2" enabled_if="WrEn_A" >
            	              <on_value>WEN_SENSE_A=0</on_value>
            	         </radio>
           	  </hline>
       </group>

	     
	
    
     	
 </page>  <!-- End of Page 2 -->

 <!-- Start of Page 3 -->

 <page id="page3">

	<line /> <!-- This is to add an line separator -->	
 	     <text> Configuring Port B </text>
 	<line /> <!-- This is to add an line separator -->


       <group text="How do you want to configure Port B ">
	  <hline>
	  	    
		  <radio id="Read_Write_B" text="Read And Write Access" enabled_if="X8_DPRAM" >		   
	      <value>true</value>
	      <on_value>READ_WRITE_B=1</on_value> 	      
	    </radio>	         

	    <radio id="Read_Only_B" text="Read Only Access" enabled_if="!Read_Only_A and X8_DPRAM" >
	    	 <value>true</value>
	         <on_value>READ_WRITE_B=2</on_value> 	         
	    </radio>	          
	    
	    <radio id="Write_Only_B" text="Write Only Access" enabled_if="!Write_Only_A and X8_DPRAM">
	        <value>false</value>
	        <on_value>READ_WRITE_B=3</on_value>	        
	    </radio>
	   </hline>
        </group>
	
	<line /> <!-- This is to add an line separator -->

       <group text="Pipelining Address Bus and Output Data ">
       
	       <check id="RADDR_LTNCY_B" text="Register address bus AddrB" level="1" enabled_if="X8_DPRAM" unchecked_if="X7_SPRAM" >
         		<value>false</value>
         		<on_value>RADDR_LTNCY_B=1</on_value>
            	        <off_value>RADDR_LTNCY_B=0</off_value>
            	</check>
            	
            	<check id="RDATA_LTNCY_B" text="Register output data bus RdDataB" level="1" enabled_if="X8_DPRAM and RADDR_LTNCY_B" checked_if="X8_DPRAM and !RADDR_LTNCY_B" unchecked_if="X7_SPRAM" >
         		<value>false</value>
         		<on_value>RDATA_LTNCY_B=1</on_value>
            	        <off_value>RDATA_LTNCY_B=0</off_value>
            	</check>
        </group>    


        <group text="Configure Reset Options" >
                 
                  <check id="RESET_B" text="Reset for RdDataB" level="1" enabled_if="X8_DPRAM and RDATA_LTNCY_B" unchecked_if="X7_SPRAM or RADDR_LTNCY_B and !RDATA_LTNCY_B" >
                  <value>true</value>
		  <on_value>ResetB=1</on_value>
            	  <off_value>ResetB=0</off_value>
            	  </check>
            	  <!-- hline >
             	         <radio id="SRST_B" text="Synchronous Reset" level="2" enabled_if="RESET_B and RADDR_LTNCY_B or RESET_B and RDATA_LTNCY_B" >
            	              <on_value>RST_TYPE_B_UI=1</on_value>
              	         </radio>
                         <radio id="ARST_B" text="Asynchronous Reset" level="2" enabled_if="RESET_B and RADDR_LTNCY_B or RESET_B and RDATA_LTNCY_B" >
            	              <on_value>RST_TYPE_B_UI=2</on_value>
            	         </radio>
           	      </hline -->
       </group>

       <group text="Specify output data on reset" >
                   <hline>
                   <check id="RST_B_DFLT"  level="1" checked_if="RESET_B and !RST_B_NDFLT" unchecked_if="!RESET_B or RESET_B and RST_B_NDFLT" enabled_if="RESET_B" >
                         <value>true</value>
                         <on_value>RST_B_DFLT=1</on_value>
                         <off_value>RST_B_DFLT=0</off_value>
                   </check>  
		   <text>Default value of '1' for all bits</text>
		   </hline>
                 
                   <hline>                  
                   <check id="RST_B_NDFLT" level="1" checked_if="RESET_B and !RST_B_DFLT" unchecked_if="!RESET_B or RESET_B and RST_B_DFLT" enabled_if="RESET_B" >
                         <value>false</value> 
                         <on_value>RST_B_NDFLT=1</on_value>
                         <off_value>RST_B_NDFLT=0</off_value>
                   </check>
                                                        
                   <lineedit id="RST_RDATA_B_UI" text="Specify Reset value for RdDataB" type="int" posttext="Valid Range 0...2^DATA_WIDTH" enabled_if="RST_B_NDFLT" required_if="RST_B_NDFLT" >
		   </lineedit>
                   </hline>
	   </group>        	 


        <group text="Configure Write Enable Options" >
                 
		<check id="WrEn_B" text="Write Enable for PORTB" level="1" enabled_if="X8_DPRAM" checked_if="X8_DPRAM" unchecked_if="!X8_DPRAM">
                  <value>true</value>
		  <on_value>WrEn_B=1</on_value>
            	  <off_value>WrEn_B=0</off_value>
            	  </check>
            	  <hline >
             	         <radio id="WrEn_B_AH" text="Active High" level="2" enabled_if="WrEn_B" >
            	              <on_value>WEN_SENSE_B=1</on_value>
              	         </radio>
                         <radio id="WeEn_B_AL" text="Active Low" level="2" enabled_if="WrEn_B" >
            	              <on_value>WEN_SENSE_B=0</on_value>
            	         </radio>
           	  </hline>
       </group>

	     
	
    
     	
 </page>  <!-- End of Page 3 -->

 <!-- Start of Page 4 -->

 <!-- page id="page4"> 
  <group text="Intialization of RAM" >
  	<line /> 
	<group text="Select the type of the Intial Values" >
  	    <hline>
  	            <radio id="BINIT_TYPE" text="Binary" >
  	            <on_value>INIT_TYPE=1</on_value>
  	            </radio>
  	  
  	            <radio id="HINIT_TYPE" text="Hexadecimal" >
  	            <on_value>INIT_TYPE=0</on_value>
  	            </radio>
  	   </hline>

  	</group>
       	<lineedit id="INIT_FILE" type="open_file" text="Intialization File" required="true" tooltip="Spaces in Directory path not supported">   
  	      <value>init.txt</value>
  	    </lineedit>
   </group>

</page --> 
<!-- End of Page 4 -->	 
	  
</hline>
</tab>


 <tab id="overview" text="Core Overview">      
      
         <lineedit id="version" text="Version:" readonly="true">
            <value>1.0</value>
         </lineedit>
         
         <lineedit id="company_name" text="Company Name:" readonly="true">
            <value>Synopsys, Inc.</value>
         </lineedit>
         
         <lineedit id="creation_date" text="Creation Date:" readonly="true">
            <value>August 4, 2009</value>
         </lineedit>
         
         <lineedit id="core_type" text="Core Type:" readonly="true">
            <value>SYNCORE Parameterizable</value>
         </lineedit>
         
	  <page id="p1">         
         <lineedit id="info" readonly="true" stretch="true" src="../../lib/html/doc1.html">
            <value type="html">

<![CDATA[
<h2>SYNCORE BYTE ENABLE RAM COMPILER</h2>
The SYNCORE Byte Enable Ram compiler helps designers create byte enable ram models for their designs.<br>
These Byte Enable Ram models are written out in HDL and can be synthesized as well as simulated.<br>
A testbench is provided for the Byte Enable Ram models created by the SYNCORE Byte Enable Ram compiler.<br> <br>
		
For detailed information on the SYNCORE Byte Enable Ram compiler and its various options, click the BYTE ENABLE RAM Info button at the bottom of this window.<br>
If you have any questions or issues, please contact support at www.solvnet.com .

]]>
         </value>
         </lineedit>
</page>         
</tab>

    <button id="generate" text="&amp;Generate" action="execute" tooltip="Generate Byte Enable Ram Core ">
            <!-- <command>generate_tcl_command</command> -->
        <command>byteenableram_proc</command> 
    </button>
    
       	<button id="cancel" text="&amp;Cancel" action="cancel" tooltip="Cancel and close dialog" />      	
       	<button id="ByteEnableRamInfo" text="&amp;BYTE ENABLE RAM Info..." width="700" height="400" action="info" filename="byte_en_ram_compiler_new.html" tooltip="Display Syncore Byte Enable Ram info" />

-->
<!-- Start of Tcl script  -->


<tcl> <![CDATA[


proc byteenableram_proc {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 } {

set COMPONENT    	 		[lindex [split $0 = ] 1 ]
set DIRECTORY     			[lindex [split $1 = ] 1 ]
set FILENAME                            [lindex [split $2 = ] 1 ] 

#### Extract extension of the the FILENAME #########
set FNAME_EXT [file extension $FILENAME]  

##### Check if extension of filename is any of {.v,.sv } and if not add ".v" extension #################

if {[string match {.v} $FNAME_EXT  ] ==0  && [string match {.sv} $FNAME_EXT  ] ==0   } {    
	  set FILENAME "$FILENAME.v"
   }
###############################   

set ADD_WIDTH                 [lindex [split $3 = ] 1 ]
set DATA_WIDTH                [lindex [split $4 = ] 1 ]
set WREN_WIDTH                [lindex [split $5 = ] 1 ]
set CONFIG_PORT               [lindex [split $6 = ] 1 ]


set READ_WRITE_A              [lindex [split $7  = ] 1 ] 
set RADDR_LTNCY_A             [lindex [split $8  = ] 1 ]
set RDATA_LTNCY_A             [lindex [split $9  = ] 1 ]

set RESET_A                   [lindex [split $10 = ] 1 ]
#set RST_TYPE_A_UI                [lindex [split $11 = ] 1 ]
set RST_A_DFLT                [lindex [split $11 = ] 1 ]
set RST_A_NDFLT               [lindex [split $12 = ] 1 ]
set RST_RDDATA_A_UI                [lindex [split $13 = ] 1 ]


set WrEn_A                    [lindex [split $14 = ] 1 ]
set WEN_SENSE_A               [lindex [split $15 = ] 1 ]


set READ_WRITE_B              [lindex [split $16 = ] 1 ] 
set RADDR_LTNCY_B             [lindex [split $17 = ] 1 ]
set RDATA_LTNCY_B             [lindex [split $18 = ] 1 ]

set RESET_B                   [lindex [split $19 = ] 1 ]
#set RST_TYPE_B_UI                [lindex [split $21 = ] 1 ]
set RST_B_DFLT                [lindex [split $20 = ] 1 ]
set RST_B_NDFLT               [lindex [split $21 = ] 1 ]
set RST_RDDATA_B_UI                [lindex [split $22 = ] 1 ]

set WrEn_B                    [lindex [split $23 = ] 1 ]
set WEN_SENSE_B               [lindex [split $24 = ] 1 ]


#set INIT_TYPE                 [lindex [split $25 = ] 1 ]
#set INIT_FILE                 [lindex [split $26 = ] 1 ]



#########  Some Initial Checks for Dual port Mode #########
if { $CONFIG_PORT == 1 } {
       ###  a)  Atleast one of the write enables should be checked ##### 
            
           if { ($WrEn_A == 0 ) && ( $WrEn_B == 0 ) } {
	           error "In Dual port mode, atleast one of the port should have a write enable"
	    }

       ###  b) If Write Enable of PortA is disabled, then the only valid option is "Read Only Acess" 
	    if { ( $WrEn_A == 0 ) && ( $READ_WRITE_A != 2 ) } {
		    error "In Dual port mode, if Write Enable of PORTA is disabled, then the only valid option for PortA is  \"Read Only Access\". Please enable this radio button for this port."
	    }

       ###  c) If Write Enable of PortB is disabled, then the only valid option is "Read Only Acess" 
	    if { ( $WrEn_B == 0 ) && ( $READ_WRITE_B != 2 ) } {
		    error "In Dual port mode, if Write Enable of PORTB is disabled, then the only valid option for PortB is \"Read Only Access\". Please enable this radio button for this port."
	    }	    


       ###  d) If both Write Enable of PortA and Read Only Access are enabled then ask user to disable one of the option.
	    if { ( $WrEn_A == 1 ) && ( $READ_WRITE_A == 2 ) } {
		    error "In Dual port mode, if Write Enable of PORTA is enabled then \"Read Only Access\" should not selected."
	    }	    

       ###  e) If both Write Enable of PortB and Read Only Access are enabled then ask user to disable one of the option.
	    if { ( $WrEn_B == 1 ) && ( $READ_WRITE_B == 2 ) } {
		    error "In Dual port mode, if Write Enable of PORTB is enabled then \"Read Only Access\" should not selected."
	    }


}


#### Check that the Data Width is greater than Write Enable width and   ####

if { $DATA_WIDTH < $WREN_WIDTH } {
	  error "The width of the Write Enable should be less than the Width of the Data Bus.Please correct the values"
} 

#### Check that the Data Width is perfect multiple of Write Enable width ####

if { [expr $DATA_WIDTH % $WREN_WIDTH] != 0 } {
	    error "Data Width should be perfect multiple of Write Enable width. Please correct the values"
    }



file mkdir $DIRECTORY


###### If the INIT_FILE field is just init.txt just touch the file ####
#####  i.e. create a blank file if it does not exist, else just change the timestamp #####
#
#if { [string match $INIT_FILE "init.txt"] } {
#	      set init_fp [open  $DIRECTORY/init.txt a]
#	      close $init_fp
#   }
#
###### Check if file exists #######
# if { [string match [file dirname  $INIT_FILE] "." ] } { 	    ### The FILENAME has just the file name
#        if {[file exists $DIRECTORY/$INIT_FILE] != 1 } {
#	        error "The Intialization File $DIRECTORY/$INIT_FILE does not exist. Please provide a valid file."
#             }
#    } else {                                              	    ### The FILENAME has a directory/filename structure
#	     if {[file exists $INIT_FILE] != 1 } {
#	        error "The Intialization File $INIT_FILE does not exist. Please provide a valid file."
#            }
#    }

#### ADDING LOCAL PARAMETERS FOR BETTER USABILITY #########
##   LOCAL parameter Assignment
 
set WE_WIDTH  $WREN_WIDTH

if {$RESET_A == 0} {     # reset port is unused
 set  RST_TYPE_A 0
} else {
#Modified on 19_08_2009 to remove asynchronous reset option - annangi   
#set  RST_TYPE_A  $RST_TYPE_A_UI 
set  RST_TYPE_A  1  
}

if {$RESET_B == 0} {     # reset port is unused
set  RST_TYPE_B  0
} else {
#Modified on 19_08_2009 to remove asynchronous reset option - annangi 
#set  RST_TYPE_B  $RST_TYPE_B_UI   
set  RST_TYPE_B  1
}

if {$RST_A_NDFLT == 1} {
set RST_RDATA_A $RST_RDDATA_A_UI
} elseif {$RST_A_DFLT == 1} {
set RST_RDATA_A \{$DATA_WIDTH\{1'b1\}\}   
} 

if {$RST_B_NDFLT == 1} {
set RST_RDATA_B $RST_RDDATA_B_UI
} elseif {$RST_B_DFLT == 1} {
set RST_RDATA_B \{$DATA_WIDTH\{1'b1\}\}   
} 
 
##Manipulating READ_WRITE_B to work with RTL code , default mode to READ mode
if {$CONFIG_PORT == 0} {
set READ_WRITE_B 2
}

##################################################

#set INIT_FILE  \"$INIT_FILE\"

#### install_dir will be path to the XML

####set install_dir [pwd]

global LIB

set install_dir $LIB/syncore/xml/memories/byte_enable_ram



if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {
file copy -force $install_dir/../../../models/memories/byte_enable_ram/syncore_be_ram_tdp.v $DIRECTORY/syncore_be_ram_tdp.v
} else {
file copy -force $install_dir/../../../models/memories/byte_enable_ram/syncore_be_ram_sdp.v $DIRECTORY/syncore_be_ram_sdp.v
}
file copy -force $install_dir/../../../models/memories/byte_enable_ram/readme.txt $DIRECTORY/readme.txt


## ----------------------------------------------------------------------------------------------
## Code for  generate options file generation
## ----------------------------------------------------------------------------------------------

set cf [open $DIRECTORY/options.txt w+]
 
puts $cf "#### Result Directory Options#####"
puts $cf "COMPONENT        =   $COMPONENT"
puts $cf "DIRECTORY        =   $DIRECTORY"
puts $cf "FILENAME         =   $FILENAME"
 
puts $cf "#### Implementation Options#####"
 
puts $cf "DATA_WIDTH        =   $DATA_WIDTH"
puts $cf "ADD_WIDTH             =   $ADD_WIDTH"
puts $cf "WE_WIDTH             =   $WE_WIDTH"


puts $cf "CONFIG_PORT         =   $CONFIG_PORT"
puts $cf "READ_WRITE_A 	    =   $READ_WRITE_A"  

if { $RADDR_LTNCY_A == 1 } {
puts $cf "RADDR_LTNCY_A      =   $RADDR_LTNCY_A"
  }

if {$RDATA_LTNCY_A == 1 } {
  puts $cf "RDATA_LTNCY_A       =   $RDATA_LTNCY_A"
  }


if { $RDATA_LTNCY_A == 1  } {
 if {$RESET_A == 1 } {
   puts $cf "RESET_A             =   $RESET_A"
   puts $cf "RST_TYPE_A          =   $RST_TYPE_A"
   
      if {$RST_A_DFLT == 1 } {
   puts $cf "RST_A_DFLT          =   $RST_A_DFLT"
        } elseif { $RST_A_NDFLT == 1 } {
   puts $cf "RST_A_NDFLT         =   $RST_A_NDFLT"
#puts $cf "RST_RDATA_A          =   $RST_RDDATA_A_UI"
        }
  }
}
  
if {$WrEn_A == 1} {
   puts $cf "WrEn_A              =   $WrEn_A"
   puts $cf "WEN_SENSE_A         =   $WEN_SENSE_A"
}
  
if { $CONFIG_PORT == 1 } {
	
   puts $cf "READ_WRITE_B = $READ_WRITE_B"
   if { $RADDR_LTNCY_B == 1 } {
      puts $cf "RADDR_LTNCY_B        =   $RADDR_LTNCY_B"
     }
  if {$RDATA_LTNCY_B == 1 } {
      puts $cf "RDATA_LTNCY_B        =   $RDATA_LTNCY_B"
     }

  if { $RDATA_LTNCY_B == 1 } { 
   
   if { $RESET_B == 1 } {
      puts $cf "RESET_B        =   $RESET_B"
#puts $cf "RST_TYPE_B     =   $RST_TYPE_B"
    
          if { $RST_B_DFLT == 1 } {
	          puts $cf "RST_B_DFLT        =   $RST_B_DFLT"
          } elseif { $RST_B_NDFLT == 1 } {
              puts $cf "RST_B_NDFLT        =   $RST_B_NDFLT"
              puts $cf "RST_RDATA_B        =   $RST_RDDATA_B_UI"
          }
     }
  }
    if {$WrEn_B == 1} {
       puts $cf "WrEn_B            =   $WrEn_B"
       puts $cf "WEN_SENSE_B        =   $WEN_SENSE_B"
	}

}
#puts $cf "INIT_TYPE        =   $INIT_TYPE"
#puts $cf "INIT_FILE        =   $INIT_FILE"



close $cf

## ----------------------------------------------------------------------------------------------


## ----------------------------------------------------------------------------------------------
## Code for Instantiation file generation
## ----------------------------------------------------------------------------------------------

set vf [open $DIRECTORY/instantiation_file.vin w+]
 
   puts $vf "// The following must be inserted into your HDL file for this"
   puts $vf "// core to be instantiated. Change the instance name and port connections"
   puts $vf "// (in parentheses) to your own signal names."
   puts $vf "\n"
   puts $vf "//----------- Begin Cut here for INSTANTIATION Template ---// INST_TAG"
   puts $vf "\n"
   
   puts $vf "$COMPONENT             #( "
   #puts $vf "                           .DATA_WIDTH($DATA_WIDTH),"
   puts $vf "                           .ADD_WIDTH($ADD_WIDTH),"
   puts $vf "                           .WE_WIDTH($WE_WIDTH),"
   puts $vf "                           .RADDR_LTNCY_A($RADDR_LTNCY_A), // 0 - No Latency , 1 - 1 Cycle Latency"
 
 if {$READ_WRITE_A != 3} {  
   puts $vf "                           .RDATA_LTNCY_A($RDATA_LTNCY_A), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 } {
   puts $vf "                           .RADDR_LTNCY_B($RADDR_LTNCY_B), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $vf "                           .RDATA_LTNCY_B($RDATA_LTNCY_B), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $vf "                           .RST_TYPE_A($RST_TYPE_A), // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_A != 0} {
   puts $vf "                           .RST_RDATA_A($RST_RDATA_A),"
 } 
 }
 if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
   puts $vf "                           .RST_TYPE_B($RST_TYPE_B), // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_B != 0} {
   puts $vf "                           .RST_RDATA_B($RST_RDATA_B),"
 } 
 }

   #puts $vf "                           .INIT_TYPE($INIT_TYPE),         // 0 - HEX file . 1- Binary file"
   #puts $vf "                           .INIT_FILE($INIT_FILE)"
   puts $vf "                           .DATA_WIDTH($DATA_WIDTH)"
   puts $vf "	                     ) "
   
   puts $vf "<InstanceName>          ( "
   
   puts $vf "                           // Output Ports "
 if {$READ_WRITE_A != 3} {
   puts $vf "			                .RdDataA(RdDataA), "
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $vf "			                .RdDataB(RdDataB), "
 }  
   puts $vf "                           // Input  Ports "
 if {$CONFIG_PORT == 1 }  {
  if {$READ_WRITE_B != 2 } { 
   puts $vf "			                .WrDataB(WrDataB), "
   puts $vf "			                .WenB(WenB), "
  }
   puts $vf "			                .AddrB(AddrB), "
  if {$RDATA_LTNCY_B == 1 && $RESET_B == 1} {  
   puts $vf "			                .ResetB(ResetB), "
  }	  
   puts $vf "			                .ClkB(ClkB), "
 }
 if {$READ_WRITE_A != 2 } {  
   puts $vf "			                .WrDataA(WrDataA), "
   puts $vf "			                .WenA(WenA), "
 }
   puts $vf "			                .AddrA(AddrA), " 
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $vf "			                .ResetA(ResetA), "
 }
   puts $vf "			                .ClkA(ClkA) "
   
   puts $vf "	                     ); "

close $vf
## ----------------------------------------------------------------------------------------------

   
## ----------------------------------------------------------------------------------------------
## Code for wrapper file generation
## ----------------------------------------------------------------------------------------------

if { [string match [file dirname  $FILENAME] "." ] } { 	    ### The FILENAME has just the file name
    set WFILENAME "$DIRECTORY/$FILENAME"
  } else {                                              	### The FILENAME has a directory/filename structure
	file mkdir [file dirname $FILENAME]
	set WFILENAME "$FILENAME"
}

set wf [open $WFILENAME w+ ]

   puts $wf "// ----------------------------------------------------------------------------- "
   puts $wf "// --- "
   puts $wf "// ---                 (C) COPYRIGHT 2001-2010 SYNOPSYS, INC. "
   puts $wf "// ---                           ALL RIGHTS RESERVED "
   puts $wf "// --- "
   puts $wf "// --- This software and the associated documentation are confidential and "
   puts $wf "// --- proprietary to Synopsys, Inc.  Your use or disclosure of this "
   puts $wf "// --- software is subject to the terms and conditions of a written "
   puts $wf "// --- license agreement between you, or your company, and Synopsys, Inc. "
   puts $wf "// --- "
   puts $wf "// --- The entire notice above must be reproduced on all authorized copies. "
   puts $wf "// --- "
   puts $wf "// ----------------------------------------------------------------------------- "
   puts $wf "// "
   puts $wf " "

   puts $wf "`timescale 1ns/100ps"
   puts $wf "\n"
   puts $wf "module    $COMPONENT #( "
   #puts $wf "                           parameter  DATA_WIDTH  =  $DATA_WIDTH,"
   puts $wf "                           parameter  ADD_WIDTH   =  $ADD_WIDTH ,"
   puts $wf "                           parameter  WE_WIDTH   =  $WE_WIDTH ,"
   puts $wf "                           parameter  RADDR_LTNCY_A   =  $RADDR_LTNCY_A , // 0 - No Latency , 1 - 1 Cycle Latency"
 
 if {$READ_WRITE_A != 3} {  
   puts $wf "                           parameter  RDATA_LTNCY_A   =  $RDATA_LTNCY_A , // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 } {
   puts $wf "                           parameter  RADDR_LTNCY_B   =  $RADDR_LTNCY_B , // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $wf "                           parameter  RDATA_LTNCY_B   =  $RDATA_LTNCY_B , // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$RDATA_LTNCY_A == 1 && $RESET_A ==1} {
   puts $wf "                           parameter  RST_TYPE_A   =  $RST_TYPE_A , // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_A != 0} {
   puts $wf "                           parameter  RST_RDATA_A   =  $RST_RDATA_A ,"
 } 
 }
 if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
   puts $wf "                           parameter  RST_TYPE_B   =  $RST_TYPE_B , // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_B != 0} {
   puts $wf "                           parameter  RST_RDATA_B   =  $RST_RDATA_B ,"
 } 
 }

#puts $wf "                           parameter  INIT_TYPE   =  $INIT_TYPE ,         // 0 - HEX file . 1- Binary file"
#puts $wf "                           parameter  INIT_FILE   =  $INIT_FILE"
puts $wf "                           parameter  DATA_WIDTH  =  $DATA_WIDTH"
 
  puts $wf "	                  ) "
  puts $wf "	                  ( "
  puts $wf " \n "
 if {$READ_WRITE_A != 3} {
	puts $wf {                           output logic [DATA_WIDTH-1:0] RdDataA, } 
 }

 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
	puts $wf {                           output logic [DATA_WIDTH-1:0] RdDataB, } 
 }  

 if {$CONFIG_PORT == 1 }  {
  if {$READ_WRITE_B != 2 } { 
	puts $wf {                           input logic [DATA_WIDTH-1:0] WrDataB, } 
	puts $wf {                           input logic [WE_WIDTH-1:0] WenB, } 
  }
	puts $wf {                           input logic [ADD_WIDTH - 1 : 0] AddrB, } 
  if {$RDATA_LTNCY_B == 1 && $RESET_B == 1} {  
	puts $wf {                           input logic [0:0] ResetB, } 
  }	  
	puts $wf {                           input logic [0:0] ClkB, } 
 }

 if {$READ_WRITE_A != 2 } {  
	puts $wf {                           input logic [DATA_WIDTH-1:0] WrDataA, } 
	puts $wf {                           input logic [WE_WIDTH-1:0] WenA, } 
 }

	puts $wf {                           input logic [ADD_WIDTH - 1 : 0] AddrA, } 

 if {$RDATA_LTNCY_A == 1 && $RESET_A ==1} {
	puts $wf {                           input logic [0:0] ResetA, } 
 }

	puts $wf {                           input logic [0:0] ClkA } 
 
  
  puts $wf {	                  ); }
  
  
  #Instantiating the ByteEnableRam
if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {
  puts $wf "parameter WR_SIZE       = DATA_WIDTH/WE_WIDTH;" 
  puts $wf "\n"
  puts $wf "genvar i; "
  puts $wf "generate "
  puts $wf "for (i=0; i<=DATA_WIDTH/WR_SIZE-1; i=i+1) begin"
  puts $wf "syncore_be_ram_tdp             #("
} else {
  puts $wf "syncore_be_ram_sdp             #("
}   
   if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {	
    puts $wf "  			 .DATA_WIDTH(WR_SIZE),"
   } else {
	puts $wf "  			 .DATA_WIDTH(DATA_WIDTH),"
  
   }	  
#puts $wf "  			 .ADD_WIDTH(ADD_WIDTH)," 
   if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {	
	puts $wf "  			 .WE_WIDTH(1),"
   } else {
	puts $wf "  			 .WE_WIDTH(WE_WIDTH),"
   }

	puts $wf "  			 .READ_WRITE_A($READ_WRITE_A)," 
	puts $wf "  			 .READ_WRITE_B($READ_WRITE_B)," 
	puts $wf "  			 .CONFIG_PORT($CONFIG_PORT)," 
   if {$RDATA_LTNCY_A == 1 && $RESET_A ==1} {	
	puts $wf "  			 .RST_TYPE_A(RST_TYPE_A)," 
   } else {
#puts $wf "  			 .RST_TYPE_A($RST_TYPE_A),"
   }
 
   if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {	
    puts $wf "  			 .RST_TYPE_B(RST_TYPE_B),"
   } else {
#puts $wf "  			 .RST_TYPE_B($RST_TYPE_B),"
   } 
   
   if {$RDATA_LTNCY_A == 1 && $RESET_A ==1 && $RST_TYPE_A != 0}	{
	puts $wf "  			 .RST_RDDATA_A(RST_RDATA_A)," 
   } else {
#puts $wf "  			 .RST_RDDATA_A($RST_RDATA_A),"  
   }
   
   if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1 && $RST_TYPE_B != 0} {
    puts $wf "  			 .RST_RDDATA_B(RST_RDATA_B)," 
   } else {
#puts $wf "  			 .RST_RDDATA_B($RST_RDATA_B),  
   }
   
   if {$READ_WRITE_A != 2 } {
	puts $wf "  			 .WEN_SENSE_A($WEN_SENSE_A)," 
   }

   if {$READ_WRITE_B != 2 } {
	puts $wf "  			 .WEN_SENSE_B($WEN_SENSE_B)," 
   }
	
	puts $wf "  			 .RADDR_LTNCY_A(RADDR_LTNCY_A)," 
   
    if {$READ_WRITE_A != 3} {	
	puts $wf "  			 .RDATA_LTNCY_A(RDATA_LTNCY_A)," 
   }	   
   
   if {$CONFIG_PORT == 1 } {
	puts $wf "  			 .RADDR_LTNCY_B(RADDR_LTNCY_B)," 
   }
   
   if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
	puts $wf "  			 .RDATA_LTNCY_B(RDATA_LTNCY_B)," 
   }	   
	
#puts $wf "  			 .INIT_TYPE(INIT_TYPE)," 
#puts $wf " 			     .INIT_FILE(INIT_FILE)"  
puts $wf "  			 .ADD_WIDTH(ADD_WIDTH)"
  	puts $wf "	                         ) "
if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {
   puts $wf "syncore_be_ram_tdp_ins1         ( "
 
 puts $wf "                           // Output Ports"
 if {$READ_WRITE_A != 3} {
   puts $wf "			                .RdDataA(RdDataA\[(i*WR_SIZE)+:WR_SIZE\]),"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $wf "			                .RdDataB(RdDataB\[(i*WR_SIZE)+:WR_SIZE\]),"
 }  
   puts $wf "                           // Input  Ports"
 if {$CONFIG_PORT == 1 }  {
  if {$READ_WRITE_B != 2 } { 
   puts $wf "			                .WrDataB(WrDataB\[(i*WR_SIZE)+:WR_SIZE\]),"
   puts $wf "			                .WenB(WenB\[i\]),"
  }
   puts $wf "			                .AddrB(AddrB),"
  if {$RDATA_LTNCY_B == 1 && $RESET_B == 1} {  
   puts $wf "			                .ResetB(ResetB),"
  }	  
   puts $wf "			                .ClkB(ClkB),"
 }
 if {$READ_WRITE_A != 2 } {  
   puts $wf "			                .WrDataA(WrDataA\[(i*WR_SIZE)+:WR_SIZE\]),"
   puts $wf "			                .WenA(WenA\[i\]),"
 }
   puts $wf "			                .AddrA(AddrA)," 
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $wf "			                .ResetA(ResetA),"
 }
   puts $wf "			                .ClkA(ClkA)"
  puts $wf "	                         ); " 
   puts $wf "end"
   puts $wf "endgenerate"   
} else {   
  puts $wf "syncore_be_ram_sdp_ins1         ( "
   puts $wf "                           // Output Ports"
 if {$READ_WRITE_A != 3} {
   puts $wf "			                .RdDataA(RdDataA),"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $wf "			                .RdDataB(RdDataB),"
 }  
   puts $wf "                           // Input  Ports"
 if {$CONFIG_PORT == 1 }  {
  if {$READ_WRITE_B != 2 } { 
   puts $wf "			                .WrDataB(WrDataB),"
   puts $wf "			                .WenB(WenB),"
  }
   puts $wf "			                .AddrB(AddrB),"
  if {$RDATA_LTNCY_B == 1 && $RESET_B == 1} {  
   puts $wf "			                .ResetB(ResetB),"
  }	  
   puts $wf "			                .ClkB(ClkB),"
 }
 if {$READ_WRITE_A != 2 } {  
   puts $wf "			                .WrDataA(WrDataA),"
   puts $wf "			                .WenA(WenA), "
 }
   puts $wf "			                .AddrA(AddrA)," 
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $wf "			                .ResetA(ResetA),"
 }
   puts $wf "			                .ClkA(ClkA)"
   
 
  puts $wf "	                         );"
}  
  
  puts $wf "endmodule"
  
  
close $wf

## ----------------------------------------------------------------------------------------------

  
## ----------------------------------------------------------------------------------------------
## Code for TestBench Generation
## ----------------------------------------------------------------------------------------------


## ----------------------------------------------------------------------------------------------
## Code for TestBench Generation
## ----------------------------------------------------------------------------------------------
if { [string match [file dirname  $FILENAME] "."] } {  ### The FILENAME has just the filename
	set TBFILE "$DIRECTORY/tb_$FILENAME" 
} else {                                               ### The FILENAME has a directory/filename structure
    set FDIR [file dirname $FILENAME]
    set FNAME [file tail $FILENAME]
	set TBFILE "$FDIR/tb_$FNAME"
}

set tf [open $TBFILE w+]


puts $tf " `timescale 1ns/1ps " 
puts $tf " //`define NETSIM "
puts $tf " \n " 
puts $tf " module tb_$COMPONENT (); " 
puts $tf " \n " 
   puts $tf " //UUT parameters "
   puts $tf "                           parameter  DATA_WIDTH  =  $DATA_WIDTH;"
   puts $tf "                           parameter  ADD_WIDTH   =  $ADD_WIDTH ;"
   puts $tf "                           parameter  WE_WIDTH   =  $WE_WIDTH ;"
   puts $tf "                           parameter  RADDR_LTNCY_A   =  $RADDR_LTNCY_A ;// 0 - No Latency , 1 - 1 Cycle Latency"
 
 if {$READ_WRITE_A != 3} {  
   puts $tf "                           parameter  RDATA_LTNCY_A   =  $RDATA_LTNCY_A ; // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 } {
   puts $tf "                           parameter  RADDR_LTNCY_B   =  $RADDR_LTNCY_B ;// 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $tf "                           parameter  RDATA_LTNCY_B   =  $RDATA_LTNCY_B ;// 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$RDATA_LTNCY_A == 1 && $RESET_A ==1} {
   puts $tf "                           parameter  RST_TYPE_A   =  $RST_TYPE_A ;// 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_A != 0} {
   puts $tf "                           parameter  RST_RDATA_A   =  $RST_RDATA_A ; "
 } 
 }
 if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
   puts $tf "                           parameter  RST_TYPE_B   =  $RST_TYPE_B ; // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_B != 0} {
   puts $tf "                           parameter  RST_RDATA_B   =  $RST_RDATA_B ;"
 } 
 }

#puts $tf "                           parameter  INIT_TYPE   =  $INIT_TYPE ;         // 0 - HEX file . 1- Binary file"
#puts $tf "                           parameter  INIT_FILE   =  $INIT_FILE ;"
   puts $tf "                           parameter  WEN_SENSE_A    = $WEN_SENSE_A;"
   puts $tf "                           parameter  WEN_SENSE_B    = $WEN_SENSE_B;" 


puts $tf " //TB parameters " 
puts $tf " parameter WR_SIZE       = DATA_WIDTH/WE_WIDTH;" 

puts $tf " \n " 
puts $tf " //UUT signals "
puts $tf { reg  [0 : 0]             ClkA    = 0; } 
puts $tf { reg  [WE_WIDTH-1 : 0]    WenA    = 0; } 
puts $tf { reg  [ADD_WIDTH-1  :  0] AddrA   = '0; } 
puts $tf " \n " 
puts $tf { reg  [0 : 0]             ResetA  = 0;  //Reset is active low } 
puts $tf " \n " 
puts $tf { reg  [DATA_WIDTH-1 :  0] WrDataA = 0; } 
puts $tf { wire [DATA_WIDTH-1 :  0] RdDataA; } 
puts $tf " \n " 
puts $tf { reg  [0 : 0]             ClkB    = 0; } 
puts $tf { reg  [WE_WIDTH-1 : 0]    WenB    = 0; } 
puts $tf { reg  [ADD_WIDTH-1  :  0] AddrB   = '1; } 
puts $tf " \n " 
puts $tf { reg  [0 : 0]             ResetB  = 0;     //Reset is active low } 
puts $tf " \n " 
puts $tf { reg  [DATA_WIDTH-1 :  0] WrDataB = 0; } 
puts $tf { wire [DATA_WIDTH-1 :  0] RdDataB; } 
puts $tf " \n " 
puts $tf " \n " 


puts $tf "$COMPONENT             #( "
   puts $tf "                           .DATA_WIDTH(DATA_WIDTH),"
#puts $tf "                         	.ADD_WIDTH(ADD_WIDTH),"
   puts $tf "                           .WE_WIDTH(WE_WIDTH),"
   puts $tf "                           .RADDR_LTNCY_A(RADDR_LTNCY_A), // 0 - No Latency , 1 - 1 Cycle Latency"
 
 if {$READ_WRITE_A != 3} {  
   puts $tf "                           .RDATA_LTNCY_A(RDATA_LTNCY_A), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 } {
   puts $tf "                           .RADDR_LTNCY_B(RADDR_LTNCY_B), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $tf "                           .RDATA_LTNCY_B(RDATA_LTNCY_B), // 0 - No Latency , 1 - 1 Cycle Latency"
 }
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $tf "                           .RST_TYPE_A(RST_TYPE_A), // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_A != 0} {
   puts $tf "                           .RST_RDATA_A(RST_RDATA_A),"
 } 
 }
 if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
   puts $tf "                           .RST_TYPE_B(RST_TYPE_B), // 0 - No Reset , 1 synchronous "
  if {$RST_TYPE_B != 0} {
   puts $tf "                           .RST_RDATA_B(RST_RDATA_B),"
 } 
 }

#puts $tf "                           .INIT_TYPE(INIT_TYPE),         // 0 - HEX file . 1- Binary file"
#puts $tf "                           .INIT_FILE(INIT_FILE)"
puts $tf "                         	.ADD_WIDTH(ADD_WIDTH)"
   puts $tf "	                     )"
   
   puts $tf "                 UUT_Test ("
   
   puts $tf "                           // Output Ports"
 if {$READ_WRITE_A != 3} {
   puts $tf "  		                    .RdDataA(RdDataA),"
 }
 if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
   puts $tf "			                .RdDataB(RdDataB),"
 }  
   puts $tf "                           // Input  Ports"
 if {$CONFIG_PORT == 1 }  {
  if {$READ_WRITE_B != 2 } { 
   puts $tf "			                .WrDataB(WrDataB),"
   puts $tf "			                .WenB(WenB),"
  }
   puts $tf "			                .AddrB(AddrB),"
  if {$RDATA_LTNCY_B == 1 && $RESET_B == 1} {  
   puts $tf "			                .ResetB(ResetB),"
  }	  
   puts $tf "			                .ClkB(ClkB),"
 }
 if {$READ_WRITE_A != 2} {  
   puts $tf "			                .WrDataA(WrDataA),"
   puts $tf "			                .WenA(WenA),"
 }
   puts $tf "			                .AddrA(AddrA)," 
 if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
   puts $tf "			                .ResetA(ResetA),"
 }
   puts $tf "			                .ClkA(ClkA)"
   
   puts $tf "	                     );"



puts $tf " \n " 
puts $tf " \n " 
puts $tf " //Clock Generation " 
puts $tf " always begin " 
puts $tf "  #10 ClkA = ~ClkA; " 
puts $tf " end " 
puts $tf " \n " 
if {$CONFIG_PORT == 1} {
puts $tf " always begin " 
puts $tf "  #10 ClkB = ~ClkB; " 
puts $tf " end " 
puts $tf " \n " 
}
puts $tf " \n " 
puts $tf " reg check_en = 0; " 
puts $tf " reg sim_done = 0;"
puts $tf " \n " 
puts $tf " //Stimulus Generation Block " 
puts $tf " initial begin " 

if {$READ_WRITE_A != 2} {
puts $tf "   //Dummy write to location '0' " 
puts $tf "   init_porta; " 
}

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 2} {
puts $tf "   //Dummy write to location '0' " 
puts $tf "   init_portb; " 
}

puts $tf "   #1500; "
if {$READ_WRITE_A == 1} {
puts $tf "   //Writing full DEPTH of memory with '0' value, all bits of wen set to 1"
puts $tf "   write_depth_porta(2**ADD_WIDTH,0,4,2);"
puts $tf " #200 " 
puts $tf " check_en = 1; " 
puts $tf "   //Readingfull DEPTH of memory"
puts $tf "   read_depth_porta(2**ADD_WIDTH,0);"
if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
 puts $tf "   read_depth_portb(2**ADD_WIDTH,0);"   
}
}
if {$READ_WRITE_A == 1} {
puts $tf "   //Writing full DEPTH of memory with random data value, all bits of wen set to 1"
puts $tf "   write_depth_porta(2**ADD_WIDTH,0,0,2);"
puts $tf "   //Readingfull DEPTH of memory"
puts $tf "   read_depth_porta(2**ADD_WIDTH,0);"
puts $tf "   clear_data(1);"
}
if {$READ_WRITE_B == 1} {
puts $tf "   //Writing full DEPTH of memory with '0' value, all bits of wen set to 1"
puts $tf "   write_depth_portb(2**ADD_WIDTH,0,4,2);"
puts $tf " #200 " 
puts $tf " check_en = 1; " 
puts $tf "   //Readingfull DEPTH of memory"
puts $tf "   read_depth_portb(2**ADD_WIDTH,0);"
if {$CONFIG_PORT == 1 && $READ_WRITE_A != 3} {
 puts $tf "   read_depth_porta(2**ADD_WIDTH,0);"   
}
}
if {$READ_WRITE_B == 1} {
puts $tf "   //Writing full DEPTH of memory with random data value, all bits of wen set to 1"
puts $tf "   write_depth_portb(2**ADD_WIDTH,0,0,2);"
puts $tf "   //Readingfull DEPTH of memory"
puts $tf "   read_depth_portb(2**ADD_WIDTH,0);"
puts $tf "   clear_data(0);"
}

puts $tf "   " 
puts $tf "   #1000; " 

if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
puts $tf "   //Reset Sequence Port A " 
puts $tf "   reset_porta; " 
}

if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
puts $tf "   //Reset Sequence Port B" 
puts $tf "   reset_portb; " 
}
if {$READ_WRITE_A != 2} {
puts $tf "   //Write Sequence PortA " 
puts $tf "   write_porta; " 
}
if {$READ_WRITE_A != 3} {

puts $tf "   //Read sequence PortA  " 
puts $tf "   read_porta; " 

}

if {$CONFIG_PORT == 1} {

if {$READ_WRITE_B != 2} {
puts $tf "   //Write Sequence PortB  " 
puts $tf "   write_portb; " 
}

if {$READ_WRITE_B != 3} {

puts $tf "   //Read Sequence Port B " 
puts $tf "   read_portb; "
}
}
puts $tf " \n " 
puts $tf "   #500; " 
puts $tf "   sim_done = 1;"
puts $tf "   //\$finish; "
puts $tf " end " 
puts $tf " \n " 
puts $tf " \n " 

puts $tf " task clear_data; " 
puts $tf " input port_select; " 
puts $tf " begin " 
puts $tf "  if (port_select) begin " 
puts $tf "    //Dummy read from location '0' " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '0; " 
puts $tf "   WrDataA   = '0; " 
puts $tf "  if(WEN_SENSE_A == 1) "
puts $tf "   WenA     = '0; " 
puts $tf "  else "
puts $tf "   WenA     = '1;"
puts $tf "  end " 
puts $tf "  else begin " 
puts $tf "   //Dummy read location '0' " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= '1; " 
puts $tf "   WrDataB   = '0; " 
puts $tf "   if (WEN_SENSE_B == 1) "
puts $tf "    WenB      = '0; " 
puts $tf "   else "
puts $tf "    WenB      = '1; "
puts $tf "  end " 
puts $tf " end " 
puts $tf " endtask " 

puts $tf " \n " 

puts $tf " task write_pattern_porta; " 
puts $tf { input [2:0] gen_pattern; } 
puts $tf " begin " 
puts $tf " integer i = 0; " 
puts $tf { reg [WR_SIZE-1 : 0] data_pattern_local ; } 
puts $tf " data_pattern_local = \$random; " 
puts $tf "  if(gen_pattern == 0) begin " 
puts $tf "   for (i= 0; i<= WR_SIZE; i = i + 1) begin " 
puts $tf {     WrDataA[(i*WR_SIZE)+:WR_SIZE] = data_pattern_local; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if (gen_pattern == 1) begin " 
puts $tf {     WrDataA = '1; } 
puts $tf "  end " 
puts $tf "  else if (gen_pattern == 2) begin " 
puts $tf "    if(WR_SIZE >= 2) begin " 
puts $tf "     for (i= 1; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {      WrDataA[i] = 1'b1; } 
puts $tf "     end " 
puts $tf "    end " 
puts $tf "    else begin" 
puts $tf {      WrDataA = '1; } 
puts $tf "    end " 
puts $tf "  end " 
puts $tf "  else begin " 
puts $tf "     WrDataA = '0; " 
puts $tf "  end " 
puts $tf " end " 
puts $tf " endtask " 

puts $tf " \n " 

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 2} {
puts $tf " task write_pattern_portb; " 
puts $tf { input [2:0] gen_pattern; } 
puts $tf " begin " 
puts $tf " integer i = 0; " 
puts $tf { reg [WR_SIZE-1 : 0] data_pattern_local ; } 
puts $tf " data_pattern_local = \$random; " 
puts $tf "  if(gen_pattern == 0) begin " 
puts $tf "   for (i= 0; i<= WR_SIZE; i = i + 1) begin " 
puts $tf {     WrDataB[(i*WR_SIZE)+:WR_SIZE] = data_pattern_local; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if (gen_pattern == 1) begin " 
puts $tf {     WrDataB = '1; } 
puts $tf "  end " 
puts $tf "  else if (gen_pattern == 2) begin " 
puts $tf "    if(WR_SIZE >= 2) begin " 
puts $tf "     for (i= 1; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {      WrDataB[i] = 1'b1; } 
puts $tf "     end " 
puts $tf "    end " 
puts $tf "    else begin" 
puts $tf {      WrDataB = '1; } 
puts $tf "    end " 
puts $tf "  end " 
puts $tf "  else begin " 
puts $tf "     WrDataB = '0; " 
puts $tf "  end " 
puts $tf " end " 
puts $tf " endtask " 

}

puts $tf " \n " 

puts $tf " task write_enable_clear_porta; " 
puts $tf " begin " 
puts $tf "    if (WEN_SENSE_A == 1) " 
puts $tf "     WenA = '0; " 
puts $tf "    else  " 
puts $tf "     WenA = '1; " 
puts $tf "    AddrA = '0; " 
puts $tf "    WrDataA = '0; " 
puts $tf " end " 
puts $tf " endtask " 

puts $tf " \n " 

puts $tf " task write_enable_clear_portb; " 
puts $tf " begin " 
puts $tf "    if (WEN_SENSE_B == 1) " 
puts $tf "     WenB = '0; " 
puts $tf "    else  " 
puts $tf "     WenB = '1; " 
puts $tf "    AddrB = '0; " 
puts $tf "    WrDataB = '0; " 
puts $tf " end " 
puts $tf " endtask " 

puts $tf "   " 

if {$READ_WRITE_A != 2} {
puts $tf " task write_enable_porta; " 
puts $tf { input [2:0] gen_pattern; } 
puts $tf " begin " 
puts $tf "  integer i = 0; " 
puts $tf "  WenA = '0; " 
puts $tf "  if(gen_pattern == 0) begin " 
puts $tf "   for (i= 0; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {     WenA[i] = 1'b1; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if(gen_pattern == 1) begin " 
puts $tf "   for (i= 1; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {     WenA[i] = 1'b1; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if(gen_pattern == 2) begin " 
puts $tf "   if (WEN_SENSE_A == 1)   " 
puts $tf "    WenA = '1; " 
puts $tf "   else " 
puts $tf "    WenA = '0; " 
puts $tf "  end " 
puts $tf "  else begin " 
puts $tf "    if (WEN_SENSE_A == 1) " 
puts $tf "     WenA = '0; " 
puts $tf "    else  " 
puts $tf "     WenA = '1; " 
puts $tf "  end " 
puts $tf " \n " 
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 
}

puts $tf " \n " 

if {$CONFIG_PORT == 1 && $READ_WRITE_A != 3} {

puts $tf " task write_enable_portb; " 
puts $tf { input [2:0] gen_pattern; } 
puts $tf " begin " 
puts $tf "  integer i = 0; " 
puts $tf "  WenB = '0; " 
puts $tf "  if(gen_pattern == 0) begin " 
puts $tf "   for (i= 0; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {     WenB[i] = 1'b1; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if(gen_pattern == 1) begin " 
puts $tf "   for (i= 1; i<= WR_SIZE; i = i + 2) begin " 
puts $tf {     WenB[i] = 1'b1; } 
puts $tf "   end " 
puts $tf "  end " 
puts $tf "  else if(gen_pattern == 2) begin " 
puts $tf "   if (WEN_SENSE_B == 1)   " 
puts $tf "    WenB = '1; " 
puts $tf "   else " 
puts $tf "    WenB = '0; " 
puts $tf "  end " 
puts $tf "  else begin " 
puts $tf "    if (WEN_SENSE_B == 1) " 
puts $tf "     WenB = '0; " 
puts $tf "    else  " 
puts $tf "     WenB = '1; " 
puts $tf "  end " 
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 
}


puts $tf " \n " 
puts $tf " \n " 

if {$READ_WRITE_A != 2} {
puts $tf " task init_porta; " 
puts $tf " begin " 
puts $tf "   //Dummy write to location '0' " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '0; " 
puts $tf "   WrDataA   = '0; " 
puts $tf "   if (WEN_SENSE_A == 1) " 
puts $tf "    WenA      = '1; " 
puts $tf "   else  " 
puts $tf "    WenA      = '0; " 
if {$CONFIG_PORT == 1} {
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '1; " 
puts $tf "   WrDataA   = '0; " 
puts $tf "   if (WEN_SENSE_A == 1) " 
puts $tf "    WenA      = '1; " 
puts $tf "   else  " 
puts $tf "    WenA      = '0; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '0; " 
}
puts $tf "   @(negedge ClkA); " 
puts $tf "   if (WEN_SENSE_A == 1) " 
puts $tf "    WenA      = '0; " 
puts $tf "   else  " 
puts $tf "    WenA      = '1; " 
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 
}

puts $tf " \n " 

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 2} {

puts $tf " task init_portb; " 
puts $tf " begin " 
puts $tf "    @(negedge ClkB); " 
puts $tf "   AddrB	= '1; " 
puts $tf "   WrDataB   = '0; " 
puts $tf "   if (WEN_SENSE_B == 1) " 
puts $tf "    WenB      = '1; " 
puts $tf "   else  " 
puts $tf "    WenB      = '0; " 
if {$CONFIG_PORT == 1} {
puts $tf "    @(negedge ClkB); " 
puts $tf "   AddrB	= '0; " 
puts $tf "   WrDataB   = '0; " 
puts $tf "   if (WEN_SENSE_B == 1) " 
puts $tf "    WenB      = '1; " 
puts $tf "   else  " 
puts $tf "    WenB      = '0; "
puts $tf "    @(negedge ClkB); " 
puts $tf "   AddrB	= '1; " 
}
puts $tf "   @(negedge ClkB); " 
puts $tf "   if (WEN_SENSE_B == 1) " 
puts $tf "    WenB      = '0; " 
puts $tf "   else  " 
puts $tf "    WenB      = '1; " 
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 
puts $tf " \n " 
}


if {$READ_WRITE_A != 2} {
puts $tf " task write_porta; " 
puts $tf " begin " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= 1; " 
puts $tf "   write_pattern_porta(0); " 
puts $tf "   write_enable_porta(0); " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= AddrA + 1; " 
puts $tf "   write_pattern_porta(0); " 
puts $tf "   write_enable_porta(1); " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= AddrA + 1; " 
puts $tf "   write_pattern_porta(2); " 
puts $tf "   write_enable_porta(4); " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '1; " 
puts $tf "   write_pattern_porta(1); " 
puts $tf "   write_enable_porta(2); " 
puts $tf "   @(negedge ClkA) " 
puts $tf "   write_enable_clear_porta; " 
puts $tf "   clear_data(1);"
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 
}


puts $tf " \n " 

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 2} {
puts $tf " task write_portb; " 
puts $tf " begin " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= 1; " 
puts $tf "   write_pattern_portb(0); " 
puts $tf "   write_enable_portb(0); " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= AddrB + 1; " 
puts $tf "   write_pattern_portb(0); " 
puts $tf "   write_enable_portb(1); " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= AddrB + 1; " 
puts $tf "   write_pattern_portb(2); " 
puts $tf "   write_enable_portb(4); " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= '1; " 
puts $tf "   write_pattern_portb(1); " 
puts $tf "   write_enable_portb(2); " 
puts $tf "   @(negedge ClkB) " 
puts $tf "   write_enable_clear_portb; " 
puts $tf "   clear_data(0); "
puts $tf " \n " 
puts $tf " end " 
puts $tf " endtask " 

}

puts $tf " \n " 

if {$READ_WRITE_A != 3} {
puts $tf " task read_porta; " 
puts $tf " begin " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= 1; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= AddrA + 1; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= AddrA + 1; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   AddrA	= '1; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   write_enable_clear_porta; " 
puts $tf "   " 
puts $tf " end " 
puts $tf " endtask " 
}

puts $tf " \n " 

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 3} {
puts $tf " task read_portb; " 
puts $tf " begin " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= 1; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= AddrB + 1; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= AddrB + 1; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   AddrB	= '1; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   write_enable_clear_portb; " 
puts $tf "   " 
puts $tf " end " 
puts $tf " endtask " 
}
puts $tf " \n " 

if {$RDATA_LTNCY_A == 1 && $RESET_A == 1} {
puts $tf " task reset_porta; " 
puts $tf " begin " 
puts $tf "    //Reset Sequence Port A " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   ResetA = 1; " 
puts $tf "   #500; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   ResetA = 0; " 
puts $tf "   #500; " 
puts $tf "   @(negedge ClkA); " 
puts $tf "   ResetA = 1; " 
puts $tf "   repeat (5) begin " 
puts $tf "    @(negedge ClkA); " 
puts $tf "   end " 
puts $tf " end " 
puts $tf " endtask " 
}

puts $tf " \n " 

if {$RDATA_LTNCY_B == 1 && $CONFIG_PORT == 1 && $RESET_B == 1} {
puts $tf " task reset_portb; " 
puts $tf " begin " 
puts $tf "  //Reset Sequence " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   ResetB = 1; " 
puts $tf "   #500; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   ResetB = 0; " 
puts $tf "   #500; " 
puts $tf "   @(negedge ClkB); " 
puts $tf "   ResetB = 1; " 
puts $tf "   repeat (5) begin " 
puts $tf "    @(negedge ClkB); " 
puts $tf "   end " 
puts $tf " end " 
puts $tf " endtask " 
}

if {$READ_WRITE_A != 2} {
puts $tf " \n "
puts $tf " task write_depth_porta; " 
puts $tf { input [ADD_WIDTH:0] write_depth; } 
puts $tf { input [ADD_WIDTH-1:0] addr_start; } 
puts $tf { input [2:0] write_data_pattern; } 
puts $tf { input [1:0] write_enable_pattern; } 
puts $tf " begin " 
puts $tf "    @(negedge ClkA) " 
puts $tf "    AddrA = addr_start; " 
puts $tf "    repeat(write_depth) begin " 
puts $tf "     @(negedge ClkA)   " 
puts $tf "      AddrA = AddrA + 1'b1; " 
puts $tf "      write_pattern_porta(write_data_pattern); // 0 - random , 1 - all bits '1' , 2 - half bits value '1' , 3 - MSB - 1, others - random " 
puts $tf "      write_enable_porta(write_enable_pattern);  // 0 - odd bits value '1' , 1 - even bits value '1' , 2 - all bits value '1' 0r '0' dpending on sense " 
puts $tf "    end " 
puts $tf " write_enable_clear_porta; " 
puts $tf " clear_data(1);"
puts $tf " end " 
puts $tf " endtask " 
puts $tf " \n " 
}

if {$CONFIG_PORT == 1 && $READ_WRITE_B != 2} {
puts $tf " task write_depth_portb; " 
puts $tf { input [ADD_WIDTH:0] write_depth; } 
puts $tf { input [ADD_WIDTH-1:0] addr_start; } 
puts $tf { input [2:0] write_data_pattern; } 
puts $tf { input [1:0] write_enable_pattern; } 
puts $tf " \n " 
puts $tf " begin " 
puts $tf "    @(negedge ClkB) " 
puts $tf "    AddrB = addr_start; " 
puts $tf "    repeat(write_depth) begin " 
puts $tf "     @(negedge ClkB)   " 
puts $tf "      AddrB = AddrB+ 1'b1; " 
puts $tf "      write_pattern_portb(write_data_pattern); // 0 - random , 1 - all bits '1' , 2 - half bits value '1' , 3 - MSB - 1, others - random " 
puts $tf "      write_enable_portb(write_enable_pattern);  // 0 - odd bits value '1' , 1 - even bits value '1' , 2 - all bits value '1' 0r '0' dpending on sense " 
puts $tf "    end " 
puts $tf " write_enable_clear_portb; " 
puts $tf " clear_data(0);"
puts $tf " end " 
puts $tf " endtask " 
puts $tf " \n " 
puts $tf " \n " 
}


puts $tf " task read_depth_porta; " 
puts $tf { input [ADD_WIDTH-1:0] read_depth; } 
puts $tf { input [ADD_WIDTH-1:0] addr_start; } 
puts $tf " begin " 
puts $tf "    @(negedge ClkA) " 
puts $tf "    if (WEN_SENSE_A == 0)   " 
puts $tf "       WenA = '1; " 
puts $tf "      else " 
puts $tf "       WenA = '0; " 
puts $tf "    AddrA = addr_start; " 
puts $tf "    repeat(read_depth) begin " 
puts $tf "     @(negedge ClkA)   " 
puts $tf "      AddrA = AddrA + 1'b1; " 
puts $tf "    end " 
puts $tf " end " 
puts $tf " endtask " 
puts $tf " \n " 
puts $tf " task read_depth_portb; " 
puts $tf { input [ADD_WIDTH-1:0] read_depth; } 
puts $tf { input [ADD_WIDTH-1:0] addr_start; } 
puts $tf " begin " 
puts $tf "    @(negedge ClkB) " 
puts $tf "    if (WEN_SENSE_B == 0)   " 
puts $tf "       WenB = '1; " 
puts $tf "      else " 
puts $tf "       WenB = '0; " 
puts $tf "    AddrB = addr_start; " 
puts $tf "    repeat(read_depth) begin " 
puts $tf "     @(negedge ClkB)   " 
puts $tf "      AddrB = AddrB + 1'b1; " 
puts $tf "    end " 
puts $tf " end " 
puts $tf " endtask " 

puts $tf " \n " 
puts $tf " \n "
puts $tf " endmodule " 

close $tf

## ----------------------------------------------------------------------------------------------


## ----------------------------------------------------------------------------------------------
## Syncore Generated files list
## ----------------------------------------------------------------------------------------------

## Filelist Generation

set lf [open $DIRECTORY/filelist.txt w+]
 puts $lf "filelist.txt             -- Contains list of files written out by SynCore"
 puts $lf "options.txt              -- Contains all the options selected in SynCore"
 puts $lf "readme.txt               -- Contains brief description and known issues"
 if { $READ_WRITE_A != 2 && $READ_WRITE_B != 2 && $CONFIG_PORT == 1} {
   puts $lf "syncore_be_ram_tdp.v     -- System Verilog library file required to generate Core Model" 	 
 } else {
   puts $lf "syncore_be_ram_sdp.v     -- System Verilog library file required to generate Core Model" 	 	 
 } 
 
 if { [ string match [file dirname  $FILENAME] "." ] } {
	 puts $lf "tb_$FILENAME       -- System Verilog testbench file to simulate Core Model"
 } else {
     puts $lf "$TBFILE            -- System Verilog testbench file to simulate Core Model"
 }

 puts $lf "$FILENAME 		        -- Core Model wrapper file"
 puts $lf "instantiation_file.vin 	-- Core Model wrapper instantiation information"
close $lf

## ----------------------------------------------------------------------------------------------


cd $install_dir


}
   ]]> </tcl>


 </dialog>
   
</dyndialog>



